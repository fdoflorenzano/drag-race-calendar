---
import * as d3 from "d3";
import moment from "moment";

import Layout from "../layouts/Layout.astro";
import Episode from "../components/Episode";

import data from "../../data.json";

console.log({ loadedData: Object.keys(data).length });

function getWeekNumber(d: string | Date) {
  const date = moment.utc(new Date(+d));
  return [
    date.isoWeek() === 53 ? date.year() - 1 : date.year(),
    date.isoWeek(),
  ];
}

function weeksInYear(year: number) {
  const d = new Date(year, 11, 31);
  const week = getWeekNumber(d)[1];
  return week == 1 ? 52 : week;
}

const parseTime = d3.utcParse("%b %e, %Y");

const startDate = new Date(2009, 0, 1);
const endDate = new Date(2024, 1, 11);

const weeks: {
  [key: string]: { year: number; week: number; weekIndex: number };
} = {};
let weekIndex = 0;
for (
  let year = startDate.getFullYear();
  year <= endDate.getFullYear();
  year++
) {
  for (let week = 1; week <= weeksInYear(year); week++) {
    weekIndex += 1;
    weeks[`${week}-${year}`] = { year, week, weekIndex };
    // console.log({ key: `${week}-${year}`, obj: { year, week, weekIndex } });
    const weekYear = getWeekNumber(endDate);
    if (year === weekYear[0] && week === weekYear[1]) {
      break;
    }
  }
}
const weeksArray = Object.values(weeks);

console.log("weeks loaded");


const versionCount = Object.keys(data).length;
let seasonCount = 0;
const countries: { [key: string]: boolean } = {};

const processedData: { [key: string]: any } = {};
for (let version in data) {
  const versionData = (data as { [key: string]: any })[version];
  const seasons = [];
  for (let season of versionData) {
    seasonCount += 1;
    if (season.country)
      countries[season.country] = true;
    const seas = { ...season, name: version, episodes: [] };
    for (let episode of season.episodes) {
      const date = parseTime(episode.date) as Date;
      const weekYear = getWeekNumber(date);
      const weekObject = weeks[`${weekYear[1]}-${weekYear[0]}`];
      // console.log({ weekObject, weekYear, date });
      const week = weekObject.weekIndex;

      const ep = { ...episode, date, week };
      seas.episodes.push(ep);
    }
    seasons.push(seas);
  }
  processedData[version] = seasons;
}

const countryCount = Object.keys(countries).length;

console.log("processes data");

const seasons = [];
for (let version in processedData) {
  const versionData = processedData[version];
  for (let season of versionData) {
    const premierDate = season.episodes[0].date;
    const premierWeek = getWeekNumber(premierDate);
    const weekStart = weeks[`${premierWeek[1]}-${premierWeek[0]}`].weekIndex;
    const finaleDate = season.episodes[season.episodes.length - 1].date;
    const finaleWeek = getWeekNumber(finaleDate);
    const weekEnd = weeks[`${finaleWeek[1]}-${finaleWeek[0]}`].weekIndex;

    seasons.push({
      ...season,
      weekStart,
      weekEnd,
      xOffset: season.xOffset ?? null,
    });
  }
}

console.log("seasons loaded");

let currentSeasons: any[] = [];
let maxOffset = 0;
for (let week of weeksArray) {
  const { weekIndex } = week;

  currentSeasons = currentSeasons.filter((s) => s.weekEnd >= weekIndex);

  for (let season of seasons) {
    if (
      season.weekStart <= weekIndex &&
      season.weekEnd >= weekIndex &&
      season.xOffset == null
    ) {
      currentSeasons.push(season);
    }
  }

  let nextOffSet = 0;
  const updateOffset = () => {
    let shouldContinue = false;
    let first = true;
    while (shouldContinue || first) {
      shouldContinue = false;
      first = false;
      for (let index = 0; index < currentSeasons.length; index++) {
        const season = currentSeasons[index];
        if (season.xOffset === nextOffSet) {
          nextOffSet += 1;
          shouldContinue = true;
          break;
        }
      }
    }
  };

  updateOffset();

  for (let season of currentSeasons) {
    if (season.xOffset == null) {
      season.xOffset = nextOffSet;
      if (maxOffset < nextOffSet) {
        maxOffset = nextOffSet;
      }
      updateOffset();
    }
  }
}

console.log("offset loaded", { maxOffset });

const episodes = [];
let streaks: any[] = [];

const usedWeeks: { [key: string]: any } = {};

for (let season of seasons) {
  const seasonStreaks = [];
  let lastSeasonWeek = null;
  for (let episode of season.episodes) {
    episode.season = season.shortTitle;
    episode.seasonName = season.name + " " + season.shortSeason;
    episode.xOffset = season.xOffset;
    episodes.push(episode);

    const weekYear = getWeekNumber(episode.date);
    const week = weeks[`${weekYear[1]}-${weekYear[0]}`].weekIndex;

    usedWeeks[week] = true;

    if (lastSeasonWeek == null) {
      lastSeasonWeek = week;
      seasonStreaks.push({
        start: week,
        end: week,
        episodes: [episode],
        unfinished: !!season.unfinished,
        season: episode.season,
      });
    } else {
      if (lastSeasonWeek + 1 === week || lastSeasonWeek === week) {
        const streak = seasonStreaks[seasonStreaks.length - 1];
        streak.end = week;
        streak.episodes.push(episode);
      } else {
        seasonStreaks.push({
          start: week,
          end: week,
          episodes: [episode],
          unfinished: !!season.unfinished,
          season: episode.season,
        });
      }
      lastSeasonWeek = week;
    }
  }
  streaks = [...streaks, ...seasonStreaks];
}

console.log("streaks loaded");

const usedWeeksArray = Object.keys(usedWeeks).map((k) => parseInt(k));
usedWeeksArray.sort((a, b) => a - b);

let generalStreaks = [];
let lastWeek = null;
for (let week of usedWeeksArray) {
  if (lastWeek == null) {
    lastWeek = week;
    generalStreaks.push({
      start: week,
      end: week,
    });
  } else {
    if (lastWeek + 1 === week || lastWeek === week) {
      const streak = generalStreaks[generalStreaks.length - 1];
      streak.end = week;
    } else {
      generalStreaks.push({
        start: week,
        end: week,
      });
    }
    lastWeek = week;
  }
}

const aux = [...generalStreaks];
generalStreaks = [];
for (let streak of aux) {
  if (generalStreaks.length === 0 || streak.end - streak.start > 30)
    generalStreaks.push(streak);
  else {
    const lastStreak = generalStreaks[generalStreaks.length - 1];
    if (lastStreak.end - lastStreak.start < streak.end - streak.start) {
      generalStreaks.push(streak);
    }
  }
}

console.log("general streaks loaded");
---

<Layout title="Historical Drag Race Timeline">
  <main>
    <h1>Historical <span class="emphasis">Drag Race</span> Timeline</h1>

    <p class="paragraph">
      This project attempts to show the historical weekly timeline of all {seasonCount} seasons of all {versionCount} Drag Race versions,
      across {countryCount} countries. 
      Displaying on the side the records for consecutive week streaks of on going weekly episodes.
    </p>

    <div
      class="timeline"
      style={{
        "--row-number": `${weeksArray.length + 1}`,
        "--track-number": `${maxOffset + 2}`,
      }}
    >
      <p
        class="legend"
        style={{ gridRow: 1, gridColumn: 1, justifySelf: "end" }}
      >
        Week
      </p>
      <p
        class="legend"
        style={{
          gridRow: 1,
          gridColumn: `2 / span ${maxOffset + 1}`,
          justifySelf: "center",
        }}
      >
        Seasons
      </p>
      <p
        class="legend"
        style={{ gridRow: 1, gridColumn: maxOffset + 3, justifySelf: "start" }}
      >
        Streaks
      </p>
      {
        weeksArray.map((d, i) => {
          const initial = moment
            .utc()
            .year(d.year)
            .isoWeek(d.week)
            .isoWeekday(1);
          const last = moment.utc().year(d.year).isoWeek(d.week).isoWeekday(7);
          return (
            <>
              <div
                class="gridRow"
                style={{
                  gridColumn: `2 / span ${1 + maxOffset}`,
                  gridRow: ` ${1 + weeksArray.length - i} / span 1`,
                }}
              />
              <div
                class="gridLabelContainer"
                style={{
                  gridRow: ` ${1 + weeksArray.length - i} / span 1`,
                }}
              >
                <p class="gridLabel">{last.format("DD MMM YY")}</p>
                <p class="gridLabel">{initial.format("DD MMM YY")}</p>
              </div>
            </>
          );
        })
      }

      {
        episodes.map((d, i) => (
          <Episode
            client:visible
            style={{
              gridColumn: `${2 + d.xOffset} / span 1`,
              gridRow: `${2 + weeksArray.length - d.week} / span 1`,
            }}
            episode={d}
          />
        ))
      }

      {
        streaks.map((d, i) => (
          <div
            class="streak"
            style={{
              "--label-offset": 0,
              gridColumn: `${2 + d.episodes[0].xOffset} / span 1`,
              gridRow: `${1 + weeksArray.length - d.end + 1} / span ${d.end - d.start + 1}`,
            }}
            data-season={d.season}
          >
            <div
              class="streakLine"
              style={{
                borderRadius: d.unfinished
                  ? `0 0 var(--col-width) var(--col-width)`
                  : `var(--col-width)`,
              }}
            />
            <p
              class="streakLabel"
              style={{
                "--label-offset": d.unfinished
                  ? "0px"
                  : "calc(var(--col-width) / 3)",
              }}
            >
              {d.season}
            </p>
          </div>
        ))
      }

      {
        generalStreaks.map((d, i) => (
          <div
            class="streak generalStreak"
            style={{
              gridColumn: `${maxOffset + 3} / span 1`,
              gridRow: `${1 + weeksArray.length - d.end + 1} / span ${d.end - d.start + 1}`,
            }}
          >
            <div class="streakLine" />
            <p
              class="streakLabel"
              style={{
                "--label-offset": "calc(var(--col-width) / 3)",
              }}
            >
              {1 + d.end - d.start} weeks
            </p>
          </div>
        ))
      }
    </div>

    <p class="paragraph">Data manually taken from <a href="https://www.imdb.com/">IMDB</a> and <a
      href="https://rupaulsdragrace.fandom.com/wiki/RuPaul%27s_Drag_Race_Wiki"
      >Drag Race Wiki</a
    >. Last updated: 30/01/2024.

      By <a href="https://github.com/fdoflorenzano">@fdoflorenzano</a>.
    </p>

  </main>
</Layout>

<style>
  main {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: fit-content;
    margin: 0 auto;

    padding: 2rem 0;
    color: white;
  }

  @media (max-width: 500px) {
    main {
      margin: 0 20px;
    }
  }

  main h1 {
    align-self: start;    
    font-size: 1.5rem;
    margin-bottom: 1rem;
    max-width: 10ch;
  }

  .emphasis {
    font-weight: normal;
  }

  .paragraph {
    align-self: start;
    max-width: 40ch;
    font-size: 0.8rem;
  }

  .paragraph > a,
  .paragraph > a:visited {
    color: var(--color-streak);
  }

  .paragraph > a:active {
    color: var(--color-general-streak);
  }

  .timeline {
    position: relative;
    display: grid;
    grid-template-columns: [labels] 1fr repeat(
        var(--track-number),
        var(--col-width)
      );
    grid-template-rows: repeat(var(--row-number), var(--col-width));
    gap: 0 var(--gap);
    margin-bottom: 3rem;

    -webkit-touch-callout:none;
    -webkit-user-select:none;
    -khtml-user-select:none;
    -moz-user-select:none;
    -ms-user-select:none;
    user-select:none;
    -webkit-tap-highlight-color:rgba(0,0,0,0);
  }

  .legend {
    user-select: none;
    margin: 0 0 0.4rem 0;
    font-size: 0.5rem;
    align-self: end;
  }

  .gridRow {
    user-select: none;
    border-style: solid;
    border-width: 1px;

    border-color: var(--color-border);
  }

  .gridRow + .gridRow {
    border-width: 1px 1px 0 1px;
  }

  .gridLabelContainer {
    user-select: none;
    align-self: center;
    justify-self: end;
  }

  .gridLabel {
    user-select: none;
    margin: 0;
    grid-column: labels / span 1;
    font-size: 0.5rem;
    text-align: end;
  }

  @media (max-width: 500px) {
    .gridLabel {
      font-size: 0.3rem;
    }
  }

  .streak {
    user-select: none;
    position: relative;
    overflow-x: visible;
  }

  .streakLine {
    user-select: none;
    height: 100%;
    background: var(--color-streak);
  }

  .generalStreak .streakLine {
    background: var(--color-general-streak);
    border-radius: var(--col-width);
  }

  .streakLabel {
    user-select: none;
    position: absolute;
    left: 0;
    top: 0;
    margin: 0;
    font-size: 0.6rem;
    transform-origin: 0 0;
    width: max-content;
    transform: rotate(90deg) translateX(calc(0.1rem + var(--label-offset)))
      translateY(calc(-1 * (var(--col-width) + 0.8rem)));
  }

  @media (max-width: 500px) {
    .streakLabel {
      transform: rotate(90deg) translateX(calc(0.1rem + var(--label-offset)))
        translateY(calc(-1 * (var(--col-width) + 0.7rem)));
      font-size: 0.5rem;
    }
  }
</style>
