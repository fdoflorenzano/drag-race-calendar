---
import * as d3 from "d3";
import moment from "moment";

import Layout from "../layouts/Layout.astro";

import data from "../../data.json";

console.log({ loadedData: Object.keys(data).length });

function getWeekNumber(d: string | Date) {
  const date = moment.utc(new Date(+d));
  return [
    date.isoWeek() === 53 ? date.year() - 1 : date.year(),
    date.isoWeek(),
  ];
}

function weeksInYear(year: number) {
  const d = new Date(year, 11, 31);
  const week = getWeekNumber(d)[1];
  return week == 1 ? 52 : week;
}

const parseTime = d3.utcParse("%b %e, %Y");

const startDate = new Date(2009, 0, 1);
const endDate = new Date(2024, 1, 11);

const weeks: {
  [key: string]: { year: number; week: number; weekIndex: number };
} = {};
let weekIndex = 0;
for (
  let year = startDate.getFullYear();
  year <= endDate.getFullYear();
  year++
) {
  for (let week = 1; week <= weeksInYear(year); week++) {
    weekIndex += 1;
    weeks[`${week}-${year}`] = { year, week, weekIndex };
    // console.log({ key: `${week}-${year}`, obj: { year, week, weekIndex } });
    const weekYear = getWeekNumber(endDate);
    if (year === weekYear[0] && week === weekYear[1]) {
      break;
    }
  }
}
const weeksArray = Object.values(weeks);

console.log("weeks loaded");

const processedData: { [key: string]: any } = {};
for (let version in data) {
  const versionData = (data as { [key: string]: any })[version];
  const seasons = [];
  for (let season of versionData) {
    const seas = { ...season, episodes: [] };
    for (let episode of season.episodes) {
      const date = parseTime(episode.date) as Date;
      const weekYear = getWeekNumber(date);
      const weekObject = weeks[`${weekYear[1]}-${weekYear[0]}`];
      // console.log({ weekObject, weekYear, date });
      const week = weekObject.weekIndex;

      const ep = { ...episode, date, week };
      seas.episodes.push(ep);
    }
    seasons.push(seas);
  }
  processedData[version] = seasons;
}

console.log("processes data");

const seasons = [];
for (let version in processedData) {
  const versionData = processedData[version];
  for (let season of versionData) {
    const premierDate = season.episodes[0].date;
    const premierWeek = getWeekNumber(premierDate);
    const weekStart = weeks[`${premierWeek[1]}-${premierWeek[0]}`].weekIndex;
    const finaleDate = season.episodes[season.episodes.length - 1].date;
    const finaleWeek = getWeekNumber(finaleDate);
    const weekEnd = weeks[`${finaleWeek[1]}-${finaleWeek[0]}`].weekIndex;

    seasons.push({
      ...season,
      weekStart,
      weekEnd,
      xOffset: season.xOffset ?? null,
    });
  }
}

console.log("seasons loaded");

let currentSeasons: any[] = [];
let maxOffset = 0;
for (let week of weeksArray) {
  const { weekIndex } = week;

  currentSeasons = currentSeasons.filter((s) => s.weekEnd >= weekIndex);

  for (let season of seasons) {
    if (
      season.weekStart <= weekIndex &&
      season.weekEnd >= weekIndex &&
      season.xOffset == null
    ) {
      currentSeasons.push(season);
    }
  }

  let nextOffSet = 0;
  const updateOffset = () => {
    let shouldContinue = false;
    let first = true;
    while (shouldContinue || first) {
      shouldContinue = false;
      first = false;
      for (let index = 0; index < currentSeasons.length; index++) {
        const season = currentSeasons[index];
        if (season.xOffset === nextOffSet) {
          nextOffSet += 1;
          shouldContinue = true;
          break;
        }
      }
    }
  };

  updateOffset();

  for (let season of currentSeasons) {
    if (season.xOffset == null) {
      season.xOffset = nextOffSet;
      if (maxOffset < nextOffSet) {
        maxOffset = nextOffSet;
      }
      updateOffset();
    }
  }
}

console.log("offset loaded", { maxOffset });

const episodes = [];
let streaks: any[] = [];

const usedWeeks: { [key: string]: any } = {};

for (let season of seasons) {
  const seasonStreaks = [];
  let lastSeasonWeek = null;
  for (let episode of season.episodes) {
    episode.season = season.shortTitle;
    episode.xOffset = season.xOffset;
    episodes.push(episode);

    const weekYear = getWeekNumber(episode.date);
    const week = weeks[`${weekYear[1]}-${weekYear[0]}`].weekIndex;

    usedWeeks[week] = true;

    if (lastSeasonWeek == null) {
      lastSeasonWeek = week;
      seasonStreaks.push({
        start: week,
        end: week,
        episodes: [episode],
        unfinished: !!season.unfinished,
        season: episode.season,
      });
    } else {
      if (lastSeasonWeek + 1 === week || lastSeasonWeek === week) {
        const streak = seasonStreaks[seasonStreaks.length - 1];
        streak.end = week;
        streak.episodes.push(episode);
      } else {
        seasonStreaks.push({
          start: week,
          end: week,
          episodes: [episode],
          unfinished: !!season.unfinished,
          season: episode.season,
        });
      }
      lastSeasonWeek = week;
    }
  }
  streaks = [...streaks, ...seasonStreaks];
}

console.log("streaks loaded");

const usedWeeksArray = Object.keys(usedWeeks).map((k) => parseInt(k));
usedWeeksArray.sort((a, b) => a - b);

let generalStreaks = [];
let lastWeek = null;
for (let week of usedWeeksArray) {
  if (lastWeek == null) {
    lastWeek = week;
    generalStreaks.push({
      start: week,
      end: week,
    });
  } else {
    if (lastWeek + 1 === week || lastWeek === week) {
      const streak = generalStreaks[generalStreaks.length - 1];
      streak.end = week;
    } else {
      generalStreaks.push({
        start: week,
        end: week,
      });
    }
    lastWeek = week;
  }
}

const aux = [...generalStreaks];
generalStreaks = [];
for (let streak of aux) {
  if (generalStreaks.length === 0 || streak.end - streak.start > 30)
    generalStreaks.push(streak);
  else {
    const lastStreak = generalStreaks[generalStreaks.length - 1];
    if (lastStreak.end - lastStreak.start < streak.end - streak.start) {
      generalStreaks.push(streak);
    }
  }
}

console.log("general streaks loaded");

const rectHeight = 20;
---

<Layout title="Drag Race Calendar">
  <main>
    <h1>Drag Race Calendar</h1>

    <div
      class="calendar"
      style={{
        "--row-number": `${weeksArray.length}`,
        "--track-number": `${maxOffset + 2}`,
      }}
    >
      {
        weeksArray.map((d, i) => {
          const initial = moment
            .utc()
            .year(d.year)
            .isoWeek(d.week)
            .isoWeekday(1);
          const last = moment.utc().year(d.year).isoWeek(d.week).isoWeekday(7);
          return (
            <>
              <div
                class="gridRow"
                style={{
                  gridColumn: `2 / span ${1 + maxOffset}`,
                  gridRow: ` ${weeksArray.length - i} / span 1`,
                }}
              />
              <div
                style={{
                  gridRow: ` ${weeksArray.length - i} / span 1`,
                  alignSelf: "center",
                  justifySelf: "end",
                }}
              >
                <p class="gridLabel">{last.format("DD MMM YY")}</p>
                <p class="gridLabel">{initial.format("DD MMM YY")}</p>
              </div>
            </>
          );
        })
      }

      {
        streaks.map((d, i) => (
          <div
            class="streak"
            style={{
              gridColumn: `${2 + d.episodes[0].xOffset} / span 1`,
              gridRow: `${weeksArray.length - d.end + 1} / span ${d.end - d.start + 1}`,
            }}
            data-season={d.season}
          >
            <div
              class="streakLine"
              style={{
                borderRadius: d.unfinished
                  ? `0 0 var(--col-width) var(--col-width)`
                  : `var(--col-width)`,
              }}
            />
            <p class="streakLabel" style={{}}>
              {d.season}
            </p>
          </div>
        ))
      }

      {
        generalStreaks.map((d, i) => (
          <div
            class="streak generalStreak"
            style={{
              gridColumn: `${maxOffset + 3} / span 1`,
              gridRow: `${weeksArray.length - d.end + 1} / span ${d.end - d.start + 1}`,
            }}
          >
            <div class="streakLine" />
            <p class="streakLabel">{1 + d.end - d.start} weeks</p>
          </div>
        ))
      }
    </div>

    <p class="paragraph">Last updated: 29/01/2024.</p>

    <p class="paragraph">
      By <a href="https://github.com/fdoflorenzano">@fdoflorenzano</a>.
    </p>
  </main>
</Layout>

<style>
  main {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: fit-content;
    margin: 0 auto;

    padding: 50px 0;
    color: white;
  }

  h1 {
    text-align: center;
    font-size: 2rem;
  }

  .paragraph {
    align-self: stretch;
  }

  .paragraph > a,
  .paragraph > a:visited {
    color: var(--color-streak);
  }

  .paragraph > a:active {
    color: var(--color-general-streak);
  }

  .calendar {
    position: relative;
    display: grid;
    grid-template-columns: [labels] 1fr repeat(
        var(--track-number),
        var(--col-width)
      );
    grid-template-rows: repeat(var(--row-number), var(--col-width));
    gap: 0 calc(0.75 * var(--col-width));
    margin-bottom: 3rem;
  }

  .gridRow {
    border-style: solid;
    border-width: 1px;

    border-color: var(--color-border);
  }

  .gridRow + .gridRow {
    border-width: 1px 1px 0 1px;
  }

  .gridLabel {
    margin: 0;
    grid-column: labels / span 1;
    font-size: 0.5rem;
    text-align: end;
  }

  .streak {
    position: relative;
    overflow-x: visible;
  }

  .streakLine {
    height: 100%;
    background: var(--color-streak);
  }

  .generalStreak .streakLine {
    background: var(--color-general-streak);
    border-radius: var(--col-width);
  }

  .streakLabel {
    position: absolute;
    left: 0;
    top: 0;
    margin: 0;
    font-size: 0.6rem;
    transform-origin: 0 0;
    width: max-content;
    transform: rotate(90deg) translateX(0.3rem)
      translateY(calc(-1 * (var(--col-width) + 0.8rem)));
  }
</style>
